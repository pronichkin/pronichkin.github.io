 <#
    # 5

    But let's now imagine you want to do something more complex. Which is not available natively in PowerShell like this.

    But you happen to know how to write this in C#. And guess what, you can call C# code from PowerShell.

    Unlike native PowerShell, you cannot just call .NET methods out of nowehere. You have to define your own artefacts. The easiest one is a method, too. Let's call it “MyBox.”
  #>

$Method = @'

    // this defines a method. First word declares the method is private
    // second defined return type. Void means nothing. No output will be returned.
    // the thrid part gives the method a name.
    // () signifies it's in fact a method.

    private void MyBox()
    {
        // once we have some code, we will add it here.
    }
'@

 <#
    What we did is wrote a small piece of c# code which defines a method.
  #>

$TypeParam = @{

    MemberDefinition     = $Method
    Name                 = 'myType05'
    UsingNamespace       = 'System.Windows.Forms'
    ReferencedAssemblies = 'System.Windows.Forms.dll'
}
Add-Type @TypeParam

 <# 
    The cmdlet did not out output anything. (We could override that if specified “-PassThru” parameter.)

    But under the hood, it did create a new object. The object is a *type,* as you could guess from cmdlet name.

    In other words, the object's type is “System.RuntimeType”. Because it was added at runtime.

    Because we did not do anything to describe the class, PowerShell created it for us. The class has a single non-default member, which is our method.

    The type's name is “Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03”. The final part of the name is what we defined in the “name” argument for Add-Type. This parameter is mandatory in this parameter set (when using Member definition.) Without it, Add-Type cannot generate the type.

    So far, the type has nothing visible in it. The type has one member, which is our method. But the method is proviate, and hence not accessible from the outside.

    The only things exposed is bare type structure.

    Because we have a type, we can create instances of it.
  #>

$Instance = [Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType05]::new()

 <#
    But so far, the instance is as useless as the type istelf. It does not expose anythign, aprart from various default methods and properties.
    
    We cannot use it to do *anything*.
  #>