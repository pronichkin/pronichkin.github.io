 <#
    # 3

    But let's now imagine you want to do something more complex. Which is not available natively in PowerShell like this.

    But you happen to know how to write this in C#. And guess what, you can call C# code from PowerShell.

    Unlike native PowerShell, you cannot just call .NET methods out of nowehere. You have to define your own artefacts. The easiest one is a method, too. Let's call it “MyBox.”
  #>

$Method = @'

    // you cannot run code by itself. It needs to be contained in some artefact
    // and the easiest option is a method. To define a method, use the following
    // syntax at minimum. Let's call our method “MyBox”. 
    
    // A method is conceptually similar to a PowerShell funciton
    // with a few differences.
    
    // First, for each method, you need to specify the output type. In our case,
    // we don't expect to output anything, but we still have to be explicit
    // about it. As such, we specify output type as “void.” Void means nothing.
    // No output will be returned.
    
    // Second, we need a place to specify the arguments, which is method input.
    // These are specified in braces after the method name. In our case, we
    // do not expect any input, but again, we have to be explicit about it.
    // Hence, we need to put an empty pair of braces there.

    void MyBox()
    {
        // once we have some code, we will add it here.
    }
'@

 <#
    What we did is wrote a small piece of c# code which defines a method.
  #>

$TypeParam = @{

    MemberDefinition     = $Method
    Name                 = 'myType03'
}
Add-Type @TypeParam

 <# 
    The cmdlet did not out output anything. (We could override that if specified “-PassThru” parameter.)

    But under the hood, it did create a new object. The object is a *type,* as you could guess from cmdlet name.

    In other words, the object's type is “System.RuntimeType”. Because it was added at runtime.

    Because we did not do anything to describe the class, PowerShell created it for us. The class has a single non-default member, which is our method.

    The type's name is “Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03”. The final part of the name is what we defined in the “name” argument for Add-Type. This parameter is mandatory in this parameter set (when using Member definition.) Without it, Add-Type cannot generate the type.

    Because we have declared a method


    So far, the type has nothing visible in it. The type has one member, which is our method. But the method is proviate, and hence not accessible from the outside.

    The only things exposed is bare type structure.

    Because we have a type, we can create instances of it.
  #>

[Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03].GetDeclaredMethods( $null )
[Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03].GetDefaultMembers()
# [Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03].GetMethods()
[Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03].DeclaredMethods

$Instance = [Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03]::new()

 <#
    But so far, the instance is as useless as the type istelf. It does not expose anythign, aprart from various default methods and properties.
    
    We cannot use it to do *anything*.
  #>