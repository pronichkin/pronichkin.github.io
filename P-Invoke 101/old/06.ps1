 <#
    # 8

  #>

$Code = @'

    public void MyBox()
    {       
        MessageBox.Show( "This is the message", "This is my caption" );
    }
'@

$TypeParam = @{

    MemberDefinition     = $Code
    Name                 = 'myType04'
    UsingNamespace       = 'System.Windows.Forms'
    ReferencedAssemblies = 'System.Windows.Forms.dll'
}
Add-Type @TypeParam

 <# 
    Now we've created another type, named “Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType04”

    It has a method called “MyBox”. But we cannot call it from the definition of the class, because it's not static.

    To use a non-static method, we need to create an instance of the class first.
  #>

$Instance = [Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType04]::new()

 <#
    Finally, we can use an instance of the class (new object) to call the method and show a message box!
  #>

$Instance.MyBox()


  <#



    The cmdlet did not out output anything. (We could override that if specified “-PassThru” parameter.)

    But under the hood, it did create a new object.

    The type is “System.RuntimeType”. Because it's a type, as you could guess from cmdlet name. And it was added at runtime.

    The type's name is “Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03”. The final part of the name is what we defined in the “name” argument for Add-Type. This parameter is mandatory. Without it, Add-Type cannot generate the type.

    But wait, this type has no methods. We cannot use it show an actual message box (or do pretty much anything.)

    To make use of it, we need to redefine our MyBox method as public.
  #>

 <#



    The newly created type has one method. Its type is “System.Management.Automation.PSMethod”
    
    The method is called “Test03”. That's the name we defined in our code.

    If you call this method, it will output a message box with the text statically defined within the code.

  #>