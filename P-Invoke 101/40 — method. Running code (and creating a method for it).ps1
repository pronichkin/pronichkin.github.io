 <#
    40. Running code (and creating a method for it)

    Let's now start adding some code to our type. But unlike PowerShell, in c#
    you cannot run code by itself. It needs to be contained in some artefact.
    The easiest option is a method. A .NET method is simlar to a function in
    PowerShell.
    
    To define a method, use the following syntax, at minimum. Unlike PowerShell,
    you don't need to explicitly say that you're defining a method. If you don't
    specify what you create, the method is the default option.
        
    A method needs a name. (There's no way to create an “anonymous method” in
   .NET, whereas in PowerShell we have scriptblocks which are “anonymous
    functions.”)
    
    Let's call our method “MyMethod”.

    For each method, you need to specify the output type. In our case,
    we don't expect to output anything, but we still have to be explicit
    about it. As such, we specify output type as “void.” Void means nothing.
    No output will be returned.

    We also need a place to specify the arguments, which is method input.
    These are specified in braces after the method name. In our case, we
    do not expect any input, but again, we have to be explicit about it.
    Hence, we need to put an empty pair of braces there.

    Finally, the actual method code goes into curly braces. This aspect of c#
    syntax is exactly the same as with functions in PowerShell. But so far,
    we don't have any code. We just added the basic conde structure to define
    the method itself.
  #>

$path = '.\40.cs'

Get-Content -Path $path

 <#
    What we did is wrote a small piece of c# code which defines a method.
  #>

$TypeParam = @{
    Path     = $path
}
Add-Type @TypeParam

 <# 
    The name of the new type is “Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType04”.

    Because we have declared a method, we can explore it.
  #>

[Pronichkin.Sample.myType40].DeclaredMembers

 <#
    Previously, this only showed the default constructor. Now theare two objects returned. One is the same default constructor, and the second is our method.

    If you only want to see the method, use this.
  #>

[Pronichkin.Sample.myType40].DeclaredMethods

 <#
    There's still no way to use this method, though. This is because it's “Private”. Which means it's not accessble from anywhere except where it was defined.

    In our case, it was defined in the c# code, which was compiled into assembly. The assembly was loaded into PowerShell. But PowerShell is outside of the assembly, so it cannot use the private method. (Even though we can explore it.)
  #>

[Pronichkin.Sample.myType40].DeclaredMethods[0].IsPrivate
[Pronichkin.Sample.myType40].DeclaredMethods[0].IsPublic

 <#
    As before, you can create an instance of this type. But it won't help either.
  #>

$myInstance40 = [Pronichkin.Sample.myType40]::new()