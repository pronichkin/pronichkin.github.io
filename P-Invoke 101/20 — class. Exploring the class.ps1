 <# 
    20. Exploring the class

    Let's explore the consequence of runing the last command. What happened under
    the hood is it did create a new object. The object is a “type” as you could
    guess from cmdlet name. A “type” in PowerShell is the same as “class” in .NET.

    In other words, the object's type is “System.RuntimeType”. Because it was
    added at runtime.
    
    The type's name is “myType03”. This is what we defined in the “name” argument
    for Add-Type. This parameter is mandatory in this parameter set (when using
    “Member Definition” parameter set, aka “From Member”.) Without it, Add-Type
    cannot generate the type. (Unless you provide full source, more of which
    later.)

    By default, the type is located at
   “Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes” namespace. But you
    could override it with “-Namespace” parameter.

    Consequently, the full name of the type is
   “Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03”.
    
    We did not do anything to describe the type, short of specifying the name.
    But PowerShell created the type for us, with all the default properties.

    In fact, it has created a temporary source code file (*.cs with a random name)
    in our temporary directory, and then compiled it and imported to our
    PowerShell session. This is what the full source code looks like.
    
    Note how it's expanded from what we have written ourselves.

        using System;
        using System.Runtime.InteropServices;

        namespace Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes
        {
            public class myType03
            {    
                // we will add some code here
            }
        }
    
    You can clearly see that the code we've written is wrapped into a class. In
    fact, our code goes where class members would normally reside. Once we add
    some actual code, it would become class member(s). This is why this way of
    calling “Add-Type” is called “From member definition”. We provide code for
    class member(s), and everything else (the class itself, with a given name,
    the namespace and references) are supplied automatically.

    But because there's no code whatsoever, the class has no members, apart from
    the default ones.
  #>

[Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03].DeclaredMembers

 <#
    This is how you explore class members. As you can see, by default, there's
    only one member, and it's a constructor.

    A constructor is what can be used to create an instance of this class. There's
    one always present by default, because normally, the whole point of class is
    to create instances.
  #>

$myInstance03 = [Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes.myType03]::new()

 <#
    This is how you call the default constructor with no parameters. It creates an
    instance of the type. But because there was no actual code, the instance is
    pretty useless, too.
  #>